
package com.birlax.indiantrader.patterndetection.oscillator;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;

import com.birlax.indiantrader.IndicatorOverlayService;
import com.birlax.indiantrader.patterndetection.PriceType;
import com.birlax.indiantrader.patterndetection.indicator.IndicatorComputationOptions;
import com.birlax.indiantrader.patterndetection.indicator.IndicatorResultHolder;
import com.birlax.indiantrader.capitalmarket.PriceVolumnDelivery;
import com.birlax.indiantrader.patterndetection.indicator.IndicatorUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * Developed by J. Welles Wilder, the Relative Strength Index (RSI) is a momentum oscillator that measures the speed and
 * change of price movements. RSI oscillates between zero and 100. Traditionally, and according to Wilder, RSI is
 * considered <b>overbought when above 70</b> and <b>oversold when below 30</b>.</br>
 * </br>
 * Signals can also be generated by looking for divergences, failure swings, and centerline crossovers.</br>
 * </br>
 * RSI can also be used to identify the general trend.</br>
 * </br>
 * Look out for <b>Positive and Negative reversals</b> for RSI, & <b>Divergence</b>.
 */
@Service
@Slf4j
public class RelativeStrengthIndex implements IndicatorOverlayService {

    public static final String RSI = "RSI";

    /*
     */
    @Override
    public IndicatorResultHolder compute(String securitySymbol, LocalDate startDate, LocalDate endDate,
            IndicatorComputationOptions options) {
        // TODO Auto-generated method stub
        return null;
    }

    public IndicatorResultHolder compute(List<PriceVolumnDelivery> priceVolumnDeliveries, Double[] rawMoney,
            IndicatorResultHolder holder, IndicatorComputationOptions options) {
        for (int lagDuration : options.getDurations()) {

            String name = options.getNameForComputationByValues(RelativeStrengthIndex.RSI, options.getFastLeg());
            if (rawMoney.length < lagDuration) {
                holder.addResult(name, new Double[rawMoney.length]);
                continue;
            }

            compute(rawMoney, priceVolumnDeliveries, holder, lagDuration, name);

        }
        return holder;
    }

    public IndicatorResultHolder compute(Double[] rawMoney, List<PriceVolumnDelivery> priceVolumnDeliveries,
            IndicatorResultHolder holder, int lagDurationPeriod, String resultName) {

        if (rawMoney.length < lagDurationPeriod) {
            holder.addResult(resultName, new Double[rawMoney.length]);
            return holder;
        }

        IndicatorComputationOptions optionPrice = new IndicatorComputationOptions(PriceType.CLOSING.toString(),
                lagDurationPeriod);

        Double[] typicalPrice = IndicatorUtil.transform(priceVolumnDeliveries, holder, optionPrice);

        Double[] changes = IndicatorUtil.getDiffWithPreviousIndex(typicalPrice);
        Double[] positiveGains = IndicatorUtil.getListOfDoubleOfSizeWithNulls(changes.length);
        Double[] negativeGains = IndicatorUtil.getListOfDoubleOfSizeWithNulls(changes.length);
        Arrays.fill(positiveGains, 0.0);
        Arrays.fill(negativeGains, 0.0);
        for (int i = 0; i < changes.length; i++) {
            if (changes[i] == null) {
                continue;
            }
            if (changes[i] >= 0) {
                positiveGains[i] = changes[i];
            }
            if (changes[i] <= 0) {
                negativeGains[i] = changes[i] * -1; // as this is gain convert to +ve;
            }
        }
        double firstAverageGains = 0.0;
        double firstAverageLosses = 0.0;

        Double[] rsi = IndicatorUtil.getListOfDoubleOfSizeWithNulls(rawMoney.length);
        int i = 0;
        int firstFewDays = lagDurationPeriod;
        while (i < changes.length && firstFewDays >= 0) {
            if (positiveGains[i] == null || negativeGains[i] == null) {
                i++;
                continue;
            }
            firstAverageGains += positiveGains[i];
            firstAverageLosses += negativeGains[i];
            i++;
            firstFewDays--;
        }
        firstAverageGains /= lagDurationPeriod;
        firstAverageLosses /= lagDurationPeriod;

        for (; i < changes.length; i++) {
            rsi[i - 1] = IndicatorUtil.getRelativeStrengthIndex(firstAverageGains, firstAverageLosses);

            firstAverageGains = (firstAverageGains * (lagDurationPeriod - 1) + positiveGains[i]) / lagDurationPeriod;
            firstAverageLosses = (firstAverageLosses * (lagDurationPeriod - 1) + negativeGains[i]) / lagDurationPeriod;
        }
        rsi[i - 1] = IndicatorUtil.getRelativeStrengthIndex(firstAverageGains, firstAverageLosses);
        holder.addResult(resultName, rsi);
        return holder;
    }

}
